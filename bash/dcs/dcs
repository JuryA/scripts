#!/usr/bin/env bash
source bashlib


# Utilities.
maxargs() {
    if [[ ${@: -1} == -- ]]; then
        xargs -0 "${@:1:$#-1}"
    else
        "$@"
    fi
}
gitg() {
    [[ -e "$dcs/git.global" ]] || ftl 'Missing global DCS repository at %s' "$dcs" || exit
    (( ! $# )) && return

    GIT_DIR="$dcs/git.global" \
    GIT_WORK_TREE="$workdir" \
    maxargs git "$@"
}
gitl() {
    [[ -e "$dcs/git.local" ]] || ftl 'Missing local DCS repository at %s' "$dcs" || exit
    (( ! $# )) && return

    GIT_DIR="$dcs/git.local" \
    GIT_ALTERNATE_OBJECT_DIRECTORIES="$dcs/git.global/objects" \
    GIT_WORK_TREE="$workdir" \
    maxargs git "$@"
}
repo_local() {
    repo_git=gitl repo_other_git=gitg repo_branch=$branch_local
}
repo_global() {
    repo_git=gitg repo_other_git=gitl repo_branch=$branch_global
}
rgit() {
    "$repo_git" "$@"
}
ogit() {
    "$repo_other_git" "$@"
}
rgithas() {
    rgit ls-files --error-unmatch "$@" >/dev/null 2>&1
}
ogithas() {
    ogit ls-files --error-unmatch "$@" >/dev/null 2>&1
}
updateRepos() {
    # Ensure both repos are available
    gitg && gitl

    # Ensure we're on the right branch
    if [[ $(gitg symbolic-ref --short HEAD) != $branch_global ]]; then
        gitg checkout -B "$branch_global"
    fi
    if [[ $(gitl symbolic-ref --short HEAD) != $branch_local ]]; then
        gitl checkout -B "$branch_local"
    fi

    # Ensure the ignores are up-to-date
    if [[ ! -e "$dcs/ignore.global" ]]; then
        echo "/.dcs.d/git.*"           >"$dcs/ignore.global"
        gitg add "$dcs/ignore.global"
    fi
    ignored=$(cat "$dcs/ignore.global"  "$dcs/ignore.local"   2>/dev/null)
    printf '%s\n' "$ignored"           >"$dcs/git.local/info/exclude"
    printf '%s\n' "$ignored"           >"$dcs/git.global/info/exclude"
    if [[ ! -e "$dcs/ignore.local" ]]; then
        touch "$dcs/ignore.local"
        gitl add "$dcs/ignore.local"
    fi
    while IFS= read -u3 -rd '' localfile; do
        # FIXME: Handle filenames with * ? and newlines in them.
        printf '/%s\n' "$localfile"
    done 3< <(gitl ls-files --full-name -z "$workdir") >>"$dcs/git.global/info/exclude"
}


# Initialize our working directory.
workdir=$(
    default=$PWD
    until [[ -e .dcs.d || $PWD = / ]]; do cd ..; done
    [[ -e .dcs.d ]] && echo "$PWD" || echo "$default"
)
dcs=$workdir/.dcs.d
branch_global=global/master
branch_local=local/${HOSTNAME%%.*}


# Run dcs action.
action=${1:-status}; shift
case $action in
    init)
        workdir=$PWD
        dcs=$workdir/.dcs.d
        if [[ ! -e "$dcs" ]]; then
            [[ $(ask -c Ny 'Initialize DCS in %s?' "$workdir") = y ]] || exit
            mkdir -p "$dcs"
        fi
        if [[ ! -e "$dcs/git.global" ]]; then
            git init --bare "$dcs/git.global"
            echo "ref: refs/heads/$branch_global" > "$dcs/git.global/HEAD"
        fi
        if [[ ! -e "$dcs/git.local" ]]; then
            git init --bare "$dcs/git.local"
            echo "ref: refs/heads/$branch_local" > "$dcs/git.local/HEAD"
        fi
        updateRepos

        ;;
    st|status)
        [[ $1 = -a ]] && all=1 && shift
        updateRepos

        inf '%s:' "$branch_global"
        if (( all )); then
            gitg ls-files "$@"
        else
            gitg status -s "$@"
        fi

        inf '%s:' "$branch_local"
        if (( all )); then
            gitl ls-files "$@"
        else
            gitl status -s --untracked=no "$@"
        fi
        ;;

    s|stage)
        stageFiles() {
            inf 'Interactively staging:'
            gitg ls-files --exclude-standard --directory --no-empty-directory -o "$@"

            while IFS= read -u3 -rd ''; do
                while true; do
                    read size _ < <(du -xsh "$REPLY")
                    count=$(gitg ls-files --exclude-standard --directory --no-empty-directory -o "$REPLY" | wc -l)
                    (( count == 1 )) && countSuffix= || countSuffix=s
                    stageAction=$(ask -c gliSec '%s [%s, %d %s] - stage %slobal, %socal, %sgnore, %skip, %snter, show %sontents?' \
                                    "$REPLY" "$size" "$count" "file$countSuffix" g l i s e c)
                    case $stageAction in
                        g) gitg add "$REPLY" && break ;;
                        l) gitl add "$REPLY" && break ;;
                        i) gitg ls-files --full-name --directory -o -z "$REPLY" >> "$dcs/ignore.global" && break ;;
                        S) break ;;
                        e) [[ -d "$REPLY" ]] && stageFiles "$REPLY" && break ;;
                        c) if [[ -d "$REPLY" ]]; then
                                gitg ls-files -o "$REPLY" | "${PAGER:-less}"
                           else
                                "${PAGER:-less}" "$REPLY"
                           fi ;;
                    esac
                done
            done 3< <(gitg ls-files --exclude-standard --directory --no-empty-directory -o -z "$@")
        }

        updateRepos
        stageFiles "$@"
        ;;

    u|unstage)
        updateRepos

        while IFS= read -u3 -rd ''; do
            gitg rm --cached "$REPLY"
        done 3< <(gitg ls-files -z "$@")
        while IFS= read -u3 -rd ''; do
            gitl rm --cached "$REPLY"
        done 3< <(gitl ls-files -z "$@")
        ;;

    g|global|l|local|G|globalize|L|localize)
        updateRepos
        repo_global
        [[ $action = [lL]* ]] && repo_local
        [[ $action = [GL] || $action = *ize ]] && move=1 || move=0

        files=()
        while IFS= read -u3 -rd ''; do
            if (( move )) || ! ogithas "$REPLY"; then
                files+=( "$REPLY" )
            fi
        done 3< <(
            if (( move )); then
                ogit ls-files --exclude-standard -z "$@"
            else
                rgit ls-files --exclude-standard -o -z "$@"
            fi
        )
        (( ${#files[@]} )) || ftl 'No files eligible.' || exit

        if (( move )); then
            inf 'Moving to %s:' "$repo_branch"
            printf '%s\n' "${files[@]}"
            printf '%s\0' "${files[@]}" | ogit rm --cached -q --
            updateRepos
        else
            inf 'Adding to %s:' "$repo_branch"
            printf '%s\n' "${files[@]}"
        fi

        printf '%s\0' "${files[@]}" | rgit add --
        ;;

    d|down|pull)
        updateRepos

        if [[ $(gitg remote show) = origin ]]; then
            inf 'Pulling %s...' "$branch_global"
            gitg pull origin "$branch_global"
        fi
        if [[ $(gitl remote show) = origin ]]; then
            inf 'Pulling %s...' "$branch_local"
            gitl pull origin "$branch_local"
        fi
        ;;

    u|up|push)
        updateRepos
        gitg commit -m "dcs global commit"
        gitl commit -m "dcs local commit" --untracked-files=no

        if [[ $(gitg remote show) = origin ]]; then
            inf 'Pushing %s...' "$branch_global"
            gitg push origin "$branch_global"
        fi
        if [[ $(gitl remote show) = origin ]]; then
            inf 'Pushing %s...' "$branch_local"
            gitl push origin "$branch_local"
        fi
        ;;

    r|remote)
        updateRepos
        if [[ $1 = -l ]]; then
            repo_local
            shift

        elif [[ $1 = -g ]]; then
            repo_global
            shift

        else
            if [[ $(ask -c Gl 'Use this remote for the %slobal or %socal repository?' g l) = G ]]; then
                repo_global
            else
                repo_local
            fi
        fi

        if [[ $(rgit remote show) = origin ]]; then
            rgit remote set-url origin "$@"
        else
            rgit remote add origin "$@"
            rgit branch -u "$repo_branch" "origin/$repo_branch"
        fi
        ;;

    *)
        ftl 'Unrecognized action: %s' "$action"
        exit 1
        ;;
esac
